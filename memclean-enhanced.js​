// memclean-compatible.js
const MEM_THRESHOLD = 20;
const CLEAN_AGGRESSIVENESS = 0.8;

// 使用兼容性检查替代$event
function checkMemory() {
  try {
    // 新方法获取内存使用
    const usage = $script.memoryUsage ? $script.memoryUsage() : 
                 $surge.memoryInfo ? $surge.memoryInfo().usage : 
                 -1;
    
    if (usage > MEM_THRESHOLD && usage !== -1) {
      const toRelease = Math.floor((usage - MEM_THRESHOLD) * CLEAN_AGGRESSIVENESS);
      console.log(`[兼容模式] 内存超标: ${usage}MB, 释放${toRelease}MB`);
      
      // 安全清理方法
      if ($cacheManager && $cacheManager.purge) {
        $cacheManager.purge("dns", toRelease * 0.5);
      }
      
      if ($network && $network.releaseIdleConnections) {
        $network.releaseIdleConnections(0.7);
      }
      
      if ($objectPool) {
        if ($objectPool.cleanStaleObjects) {
          $objectPool.cleanStaleObjects(0.6);
        }
        if ($objectPool.releaseObjectsByType) {
          $objectPool.releaseObjectsByType("SGSocket", 0.4);
          $objectPool.releaseObjectsByType("SGTrojanConnector", 0.5);
        }
      }
      
      return {released: toRelease};
    }
    return {status: "正常"};
  } catch (e) {
    console.error(`内存监控错误: ${e.message}`);
    return {error: e.message};
  }
}

// 主执行逻辑
const result = checkMemory();
$done(result);
